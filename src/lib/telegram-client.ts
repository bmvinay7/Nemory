interface TelegramMessage {
  chatId: string;
  summary: string;
  actionItems: Array<{
    text: string;
    priority: string;
    dueDate?: string;
    category: string;
  }>;
  keyInsights: string[];
  priority: string;
  readingTime: number;
  createdAt: string;
}

interface TelegramDeliveryResult {
  success: boolean;
  messageId?: number;
  error?: string;
}

class TelegramClientService {
  private botToken: string;
  private baseUrl: string;

  constructor() {
    // You'll need to set this in your environment variables
    this.botToken = import.meta.env.VITE_TELEGRAM_BOT_TOKEN || '';
    this.baseUrl = `https://api.telegram.org/bot${this.botToken}`;
  }

  /**
   * Validate chat ID format
   */
  validateChatId(chatId: string): { isValid: boolean; error?: string } {
    if (!chatId || chatId.trim() === '') {
      return { isValid: false, error: 'Chat ID is required' };
    }

    // Telegram chat IDs can be numbers or strings starting with @
    const trimmedId = chatId.trim();
    if (!/^-?\d+$/.test(trimmedId) && !trimmedId.startsWith('@')) {
      return { isValid: false, error: 'Invalid chat ID format' };
    }

    return { isValid: true };
  }

  /**
   * Format summary content for Telegram message
   */
  private formatSummaryForTelegram(data: TelegramMessage): string {
    const { summary, actionItems, keyInsights, priority, readingTime } = data;
    
    let message = `ðŸ§  *Nemory AI Summary*\n\n`;
    
    // Priority indicator
    const priorityEmoji = priority === 'high' ? 'ðŸ”´' : priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
    message += `${priorityEmoji} *Priority:* ${priority.toUpperCase()}\n`;
    message += `â±ï¸ *Reading Time:* ${readingTime} minutes\n\n`;
    
    // Main summary
    message += `ðŸ“ *Summary:*\n${summary}\n\n`;
    
    // Key insights
    if (keyInsights.length > 0) {
      message += `ðŸ’¡ *Key Insights:*\n`;
      keyInsights.forEach((insight, index) => {
        message += `${index + 1}\\. ${insight}\n`;
      });
      message += `\n`;
    }
    
    // Action items
    if (actionItems.length > 0) {
      message += `âœ… *Action Items \\(${actionItems.length}\\):*\n`;
      actionItems.forEach((item, index) => {
        const priorityIcon = item.priority === 'high' ? 'ðŸ”´' : item.priority === 'medium' ? 'ðŸŸ¡' : 'ðŸŸ¢';
        message += `${index + 1}\\. ${priorityIcon} ${item.text.replace(/[_*[\]()~`>#+=|{}.!-]/g, '\\$&')}`;
        if (item.dueDate) {
          message += ` \\(Due: ${item.dueDate}\\)`;
        }
        message += `\n`;
      });
      message += `\n`;
    }
    
    message += `\\-\\-\\-\n`;
    message += `Generated by Nemory AI ðŸš€\n`;
    message += `${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`;
    
    return message;
  }

  /**
   * Send message via Telegram Bot API
   */
  async sendMessage(chatId: string, text: string): Promise<TelegramDeliveryResult> {
    try {
      if (!this.botToken) {
        return {
          success: false,
          error: 'Telegram bot token not configured'
        };
      }

      const validation = this.validateChatId(chatId);
      if (!validation.isValid) {
        return {
          success: false,
          error: validation.error
        };
      }

      const response = await fetch(`${this.baseUrl}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: chatId,
          text: text,
          parse_mode: 'MarkdownV2'
        }),
      });

      const result = await response.json();

      if (response.ok && result.ok) {
        return {
          success: true,
          messageId: result.result.message_id,
        };
      } else {
        return {
          success: false,
          error: result.description || 'Failed to send Telegram message',
        };
      }

    } catch (error) {
      console.error('Telegram delivery error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Network error occurred',
      };
    }
  }

  /**
   * Send summary via Telegram
   */
  async sendSummary(data: TelegramMessage): Promise<TelegramDeliveryResult> {
    try {
      const messageText = this.formatSummaryForTelegram(data);
      return await this.sendMessage(data.chatId, messageText);
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to format message',
      };
    }
  }

  /**
   * Send test message
   */
  async sendTestMessage(chatId: string): Promise<TelegramDeliveryResult> {
    const testMessage = `ðŸ§  *Nemory AI Test Message*\n\n` +
      `Hello\\! This is a test message from Nemory AI\\.\n\n` +
      `Your Telegram integration is working correctly\\! ðŸŽ‰\n\n` +
      `\\-\\-\\-\n` +
      `Generated at ${new Date().toLocaleString()}`;

    return await this.sendMessage(chatId, testMessage);
  }

  /**
   * Get bot info (for testing)
   */
  async getBotInfo(): Promise<any> {
    try {
      if (!this.botToken) {
        throw new Error('Bot token not configured');
      }

      const response = await fetch(`${this.baseUrl}/getMe`);
      const result = await response.json();
      
      if (result.ok) {
        return result.result;
      } else {
        throw new Error(result.description || 'Failed to get bot info');
      }
    } catch (error) {
      console.error('Error getting bot info:', error);
      throw error;
    }
  }

  /**
   * Check if bot token is configured
   */
  isConfigured(): boolean {
    return !!this.botToken;
  }
}

export const telegramClientService = new TelegramClientService();
export type { TelegramDeliveryResult, TelegramMessage };