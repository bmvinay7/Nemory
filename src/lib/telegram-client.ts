import RobustErrorHandler from './robust-error-handler';

interface TelegramMessage {
  chatId: string;
  summary: string;
  actionItems: Array<{
    text: string;
    priority: string;
    dueDate?: string;
    category: string;
  }>;
  keyInsights: string[];
  priority: string;
  readingTime: number;
  createdAt: string;
}

interface TelegramDeliveryResult {
  success: boolean;
  messageId?: number;
  error?: string;
}

class TelegramClientService {
  private botToken: string;
  private baseUrl: string;

  constructor() {
    // Validate bot token from environment
    this.botToken = import.meta.env.VITE_TELEGRAM_BOT_TOKEN || '';
    if (this.botToken && !this.botToken.match(/^\d+:[A-Za-z0-9_-]{35}$/)) {
      console.error('Invalid Telegram bot token format');
      this.botToken = '';
    }
    this.baseUrl = `https://api.telegram.org/bot${this.botToken}`;
  }

  /**
   * Validate chat ID format with strict validation
   */
  validateChatId(chatId: string): { isValid: boolean; error?: string } {
    const validation = RobustErrorHandler.validateChatId(chatId);
    return {
      isValid: validation.isValid,
      error: validation.error
    };
  }

  /**
   * Secure text escaping for Telegram HTML format
   */
  private escapeHtml(text: string): string {
    return RobustErrorHandler.sanitizeForTelegram(text);
  }

  /**
   * Format summary content for Telegram message with security measures
   */
  private formatSummaryForTelegram(data: TelegramMessage): string {
    // Validate input data
    if (!data || typeof data !== 'object') {
      throw new Error('Invalid message data');
    }

    const { summary, actionItems, keyInsights, priority, readingTime } = data;
    
    // Validate required fields
    if (!summary || typeof summary !== 'string') {
      throw new Error('Invalid summary data');
    }

    let message = `üß† <b>Nemory AI Summary</b>\n\n`;
    
    // Priority indicator with validation
    const validPriorities = ['high', 'medium', 'low'];
    const safePriority = validPriorities.includes(priority) ? priority : 'medium';
    const priorityEmoji = safePriority === 'high' ? 'üî¥' : safePriority === 'medium' ? 'üü°' : 'üü¢';
    
    message += `${priorityEmoji} <b>Priority:</b> ${safePriority.toUpperCase()}\n`;
    message += `‚è±Ô∏è <b>Reading Time:</b> ${Math.max(1, Math.min(readingTime || 1, 60))} minutes\n\n`;
    
    // Main summary with length limit
    const truncatedSummary = summary.length > 2000 ? summary.substring(0, 2000) + '...' : summary;
    message += `üìù <b>Summary:</b>\n${this.escapeHtml(truncatedSummary)}\n\n`;
    
    // Key insights with validation
    if (Array.isArray(keyInsights) && keyInsights.length > 0) {
      message += `üí° <b>Key Insights:</b>\n`;
      keyInsights.slice(0, 5).forEach((insight, index) => {
        if (insight && typeof insight === 'string') {
          const truncatedInsight = insight.length > 200 ? insight.substring(0, 200) + '...' : insight;
          message += `${index + 1}. ${this.escapeHtml(truncatedInsight)}\n`;
        }
      });
      message += `\n`;
    }
    
    // Action items with validation
    if (Array.isArray(actionItems) && actionItems.length > 0) {
      message += `‚úÖ <b>Action Items (${Math.min(actionItems.length, 10)}):</b>\n`;
      actionItems.slice(0, 10).forEach((item, index) => {
        if (item && typeof item === 'object' && item.text) {
          const validItemPriorities = ['high', 'medium', 'low'];
          const itemPriority = validItemPriorities.includes(item.priority) ? item.priority : 'medium';
          const priorityIcon = itemPriority === 'high' ? 'üî¥' : itemPriority === 'medium' ? 'üü°' : 'üü¢';
          
          const truncatedText = item.text.length > 150 ? item.text.substring(0, 150) + '...' : item.text;
          message += `${index + 1}. ${priorityIcon} ${this.escapeHtml(truncatedText)}`;
          
          if (item.dueDate && typeof item.dueDate === 'string') {
            const sanitizedDate = item.dueDate.replace(/[^\d\-\/\s:]/g, '').substring(0, 20);
            message += ` (Due: ${this.escapeHtml(sanitizedDate)})`;
          }
          message += `\n`;
        }
      });
      message += `\n`;
    }
    
    message += `---\n`;
    message += `Generated by Nemory AI üöÄ\n`;
    const safeDate = new Date().toLocaleDateString().replace(/[^\d\/\-]/g, '');
    const safeTime = new Date().toLocaleTimeString().replace(/[^\d:APM\s]/g, '');
    message += `${this.escapeHtml(safeDate)} at ${this.escapeHtml(safeTime)}`;
    
    // Final length check
    if (message.length > 4096) {
      message = message.substring(0, 4090) + '...';
    }
    
    return message;
  }

  /**
   * Send message via Telegram Bot API with security measures
   */
  async sendMessage(chatId: string, text: string): Promise<TelegramDeliveryResult> {
    try {
      if (!this.botToken) {
        return {
          success: false,
          error: 'Telegram bot token not configured'
        };
      }

      const validation = this.validateChatId(chatId);
      if (!validation.isValid) {
        return {
          success: false,
          error: validation.error
        };
      }

      // Validate message text
      if (!text || typeof text !== 'string' || text.trim().length === 0) {
        return {
          success: false,
          error: 'Message text is required'
        };
      }

      // Limit message length
      const truncatedText = text.length > 4096 ? text.substring(0, 4090) + '...' : text;

      const response = await fetch(`${this.baseUrl}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: chatId.trim(),
          text: truncatedText,
          parse_mode: 'HTML'
        }),
      });

      const result = await response.json();

      if (response.ok && result.ok) {
        return {
          success: true,
          messageId: result.result.message_id,
        };
      } else {
        return {
          success: false,
          error: result.description || 'Failed to send Telegram message',
        };
      }

    } catch (error) {
      console.error('Telegram delivery error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Network error occurred',
      };
    }
  }

  /**
   * Send summary via Telegram with security validation
   */
  async sendSummary(data: TelegramMessage): Promise<TelegramDeliveryResult> {
    try {
      // Validate input data structure
      if (!data || typeof data !== 'object') {
        return {
          success: false,
          error: 'Invalid message data provided'
        };
      }

      if (!data.chatId || !data.summary) {
        return {
          success: false,
          error: 'Missing required message fields'
        };
      }

      const messageText = this.formatSummaryForTelegram(data);
      return await this.sendMessage(data.chatId, messageText);
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to format message',
      };
    }
  }

  /**
   * Send test message with security validation
   */
  async sendTestMessage(chatId: string): Promise<TelegramDeliveryResult> {
    const testMessage = `üß† <b>Nemory AI Test Message</b>\n\n` +
      `Hello! This is a test message from Nemory AI.\n\n` +
      `Your Telegram integration is working correctly! üéâ\n\n` +
      `---\n` +
      `Generated at ${this.escapeHtml(new Date().toLocaleString())}`;

    return await this.sendMessage(chatId, testMessage);
  }

  /**
   * Get bot info with timeout and error handling
   */
  async getBotInfo(): Promise<any> {
    try {
      if (!this.botToken) {
        throw new Error('Bot token not configured');
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

      const response = await fetch(`${this.baseUrl}/getMe`, {
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      const result = await response.json();
      
      if (result.ok) {
        return result.result;
      } else {
        throw new Error(result.description || 'Failed to get bot info');
      }
    } catch (error) {
      console.error('Error getting bot info:', error);
      throw error;
    }
  }

  /**
   * Check if bot token is configured and valid
   */
  isConfigured(): boolean {
    return !!this.botToken && this.botToken.match(/^\d+:[A-Za-z0-9_-]{35}$/) !== null;
  }
}

export const telegramClientService = new TelegramClientService();
export type { TelegramDeliveryResult, TelegramMessage };